# 前端知识领域

## 前言

任何一个领域的学习都是不断迭代、不断纠错的过程，如果想要成为一个领域的专家，就需要不停的不停的进行无止境的迭代与纠错，建立自己的思维体系、建立自己的知识体系。

## 1.设计模式

### 前言

软件设计的思想是针对反复出现的问题，基于可复用、经验证的解决方案，提供一套可共享的设计词汇，提高沟通和开发的效率。设计模式一共分为工厂模式、代理模型以及策略模式.......

### 工厂模式

工厂模式提供一个统一的入口，通过传递一个参数来返回不同类型的对象，具体的处理细节在工厂内部，这样可以降低代码的耦合度

但是在类型太多的情况下，会使工厂变得复杂难以管理

### 代理模式

代理模式在性能优化方向使用甚广

虚拟代理 如懒加载 先显示一个轻量占位符，然后根据需要再加载对应内容

缓存代理 计算成本很高 可以使用缓存 用额外的内存去换时间、性能与数据一致性

### 策略模式

策略模式的核心在于封装，针对不同情况设置不同的策略类，在使用时，使用这个策略类就好了

### 总结

我在实习的时候，印象比较深的一个地方就是，business组件的使用，它是一个表单表格的封装组件，可以通过type值的设置、自定义表单和表格去设置自己需要的搜索项与表格项，它使用的设计模式就是工厂模式+策略模型，即根据不同的业务逻辑，不同的服务，去设置不同的搜索项与表格项，你可以在business文件夹下面创建自己的type文件，然后在使用时，传入一个type的props参数，然后business就相当一个工厂会进行具体的处理。

## 2.数据结构与算法

### 前言

数据结构就是数据的组织形式，算法就是使用数据去解决问题的方案，复杂度是衡量方案性能的指标，程序=数据结构+算法

### 数据结构

数据结构分为集合、线性结构、层级结构、图

集合的数据是没有秩序的，线性结构的数据是有秩序的，层级结构有层级，图是数据之间的连接

哈希表是一个智能的字典，可以通过特殊的查询算法用O(1)的效率去查询数据的存储位置

虚拟DOM+diff算法就是树数据结构+查询算法的应用

### 算法

这一部分我的知识是空白的，后面需要去深入去学习

### 复杂度

复杂度是衡量算法效率的指标，复杂度分为时间复杂度和空间复杂度，在复杂度中，O(1) O(n) 的算法是性能很高的算法，O(n2)的算法是性能较弱的算法

在大数据时代，当数据规模提升之后，算法的性能指标就非常重要

### 总结

我个人觉得，这一部分真是越来越有趣了，这一个月有深入学习的价值

## 3.计算机网络

### 前言

计算机网络在前端领域的部分主要是网络模型、TCP/UDP、HTTP与HTTPS、GET和POST........

### 网络模型

计算机网络的模型分为OSI模型和TCP/IP模型，其中OSI模型分为应用层、表示层、会话层、传输层、网络层、数据链路层、物理层，是理论上最为完善的数据模型，但是应用起来却非常的繁杂；应用很广的是TCP/IP模型，其中应用层封装了上三层，数据接口层封装了下两层，重点在于传输层和网络层

网络模型最重要的是分层的思想，将复杂的问题拆分为一个个小问题

### TCP和UDP

TCP和UDP是传输层的两种不同的协议，其中TCP是数据控制协议，它是一种面向连接的协议，数据传输之前会进行三次握手的连接确认，然后通过数据丢失就重新发送的机制确保数据的完整性。虽然开销会大一点，速度回慢一点，不过可靠性会高一些，适用于文字这种需要精准传输的数据。像HTTP、FTP、SMTP这种以文字作为数据的应用层协议都是建立在TCP之上的

UDP是用户数据协议，采用无连接、不可靠的连接模式，适用于数据不是文字，而是音频、视频的数据

### GET和POST

GET和POST是网络请求的两种常见方法，GET是获取数据，POST是发送数据，GET在URI中会显示，POST不会

但是还是需要加密手段对网络传输的数据进行加密

### HTTP和HTTPS

HTTPS是HTTP+SSL/TSL，通过三种加密方式来实现加密传输

会话密钥 双方协商密码 再传输

数字证书，确保连接方是正确的，防止被钓鱼

完整性校验 用指纹去证明

HTTPS在443 HTTP在80

### 总结

计算机网络在前端部分，是传统的计算机网络+信息安全，对我而言非常有趣，我还想去浅浅的学习一下web3.0的方向，感觉会很有趣

## 4.操作系统

### 前言

操作系统在前端部分的学习，主要是操作系统的基础概念与浏览器架构的解析

### 操作系统的基础概念

进程与线程的区别





### 浏览器架构

浏览器架构的组成



浏览器的渲染机制



浏览器的垃圾处理机制



### 总结





## 5.前端架构

### 前言

这一部分，是我自己想要去学习的，我觉得以上5个专题是前端领域的基础知识或者说理论基石









## 6.JS

### 数据结构

**数据类型这一专题，包括JS的基本数据类型、内存空间、作用**

JS中的数据类型一共分为两种，分别为基本数据类型与复杂数据类型

其中基本数据类型有7种，它们属于值类型，内存空间是栈

- string 字符型
- number 数值型
- boolean 布尔型
- undefine 未定义
- null 空
- symbol 符号
- bigint 大整数

复杂数据类型有2种，它们属于引用类型，内存空间是堆，引用在栈中存储

- array 数组
- object 对象

基本数据类型 栈 简单固定

引用数据类型 数据在堆里面 复杂量大 引用在栈里面



### 变量声明

var 变量提升 函数作用域(全局作用域) 

let const 主要解决变量提升的问题 块级作用域  在声明前使用会报错，叫做暂时性死区

let 定义变量 重复赋值

const 变量指向的地址不变 声明对象或者数组 对象和数组内部的元素是可以改的  const在声明对象的时候，引用不变，浅层不变  优先用const

let const主要解决变量提升的问题，块级作用域叫做暂时性死区，const声明对象，引用不变，属性可变，优先const

### 闭包

**闭包的定义**

闭包是JS非常重要的特性，即子函数可以访问外部函数的变量

**闭包的作用**

闭包的作用有两个保存与保护：

- 保存是将子函数中的变量存储在内存中，即函数执行完毕后，变量依旧存在(这也会造成内存泄漏问题)
- 保护是为了避免其他变量的污染

### 原型链





### 垃圾回收机制





### this

值怎么被调用的，当做对象方法来调用 直接调用函数 非严格模式 指向全局

call apply bind强制改变指向this

es6中的箭头函数，自己没有自己的this，this来定义的时候被定下了，继承的是词法作用域中的this，定义时，外层是什么

闭包 函数执行完了，可以继续访问变量 创建私有变量实现数据封装 通过方法访问 延长变量的生存周期  模块化开发 每个模块都有自己的状态 闭包对于深入掌握JS非常重要



### 异步编程

以前异步编程 回调地狱 代码一层套一层 维护麻烦

promise为了解决回调地狱，本质是一个对象，异步操作最终状态的表示，三个状态 pending rejected fullfiled

链式调用 代码同步

promise.all 多个promise并发执行 promise数组 所有promise都成功才成功，将结果给一个数组   一个失败，失败，将失败原因给你，不会给全部结构

界面加载 用户信息 配置 产品信息 promise.all非常方便

promise解决回调地狱问题，链式调用，同步呈现异步操作，界面渲染，用户信息、产品信息、配置信息用promise.all来并行处理，全部成功返回全部成功用数组的形式返回全部成功结构，一个失败直接返回失败原因





## 7.CSS

#### 盒子模型

content-box  正常盒模型 分别计算width height margin padding

border-box width和height将margin和padding包含进去了

像素级对齐

#### BFC 块级格式化上下文

核心在于隔离，BFC可以解决不少问题，将浮动元素包裹，解决父元素塌陷的问题，外边距叠加问题

#### 元素居中

flex和grid实现元素居中

display flex justify-conent:center  

grid 

flex主要是一维布局系统 单行和单列元素的对齐 flex box非常顺畅

grid控制行和列 整个界面的宏观布局 圣杯布局 

小范围、组件内部使用flex好一些，grid宏观布局

#### 计算单位

px绝对单位 vm相对单位，根元素尺寸，

无障碍访问

#### 总结

盒子模型 content-box 单独计算各个部分 border-box 宽高决定一切

BFC 隔离元素 解决元素坍塌问题 边距叠加问题

元素居中 flex grid

计算单位 响应式

我的css基础真的很差劲！！！！

## 8.JS框架

### vue前言知识

#### （1）组合式API

vue3和vue2在关于代码组织的上面给出了不同的答案，vue2使用的是配置式API，data、method、watch都要分开组织，不同功能的数据、方法、监听都混在了一起；而vue3使用的是组合式API，将相同功能的数据、方法等逻辑放在一起，以提高代码的内聚性；

最典型的例子就是mixin，mixin的数据不清晰，需要使用hook来提高，复用逻辑清晰可见

#### （2）响应式系统

vue2的响应式系统使用的是defineProperty，具有数据增删改存在监视缺漏、数组类型数据监视不了的问题；而vue3使用的是ES6的proxy，相当于给整个数据对象都加上了一层代理，统一监视所有数据对象的变化，不需要额外的API，性能也更好，但是存在不兼容老IE的问题，不过babel会帮助我们解决的！

vue3的响应式系统使用的JS的原生功能，解决了数据对象的监视问题，提高了性能

#### （3）性能优化

在diff算法上，编译阶段会将变化的状态进行标记，然后只比较标记的部分，减少不必要的比较，提高diff的性能

编译器会将静态内容提取出来，采用静动态代码分割策略，一次复用（静态提升）

tree shaking会将没用到的代码都摇掉，减小包的体积

组件传送门可以全局处理UI元素

#### （4）总结

vue3与vue2的不同在于，代码组织模式、响应式系统和性能优化上，其中代码组织模式使用了功能逻辑更加清晰可见的组合式API，响应式系统使用了proxy来统一加上一层代理进行数据监视，性能优化上包括编译时的diff标记、静动态代码分割、tree shakiing，使用上引用了功能繁多的hook

### react前言知识

前言部分，包括声明式编程、组件化、虚拟DOM以及fiber架构

#### （1）声明式编程

声明式编程就是告诉程序是什么，而不是怎么做，不需要操作dom，直接专注解决问题的逻辑

#### （2）组件化

react中的组件分为类组件和函数组件，早期的类组件可以通过this.state设置自身状态，而函数组件没有状态；react16之后，引入了hook，解决了函数组件没有状态的问题，可以使用useState来设置状态；现在越来越倾向于函数式编程。

说到状态，分为外部状态与自身状态，外部状态通过props来进行组件通信，内部状态通过useState来设置

#### （3）虚拟DOM

直接操作DOM的成本较高，虚拟DOM就是JS对象，操作虚拟DOM的成本较小，再加上diff算法，就可以精准的操作变化的部分，大大提高性能

在进行列表渲染的时候，需要为元素添加key，相当于为每一项列表元素添加身份证，这样再使用diff算法，就可以精确的完成变动，提高性能

#### （4）fiber架构

react16之前，在执行任务的时候，需要一鼓作气的完成，不能中断，中断就要重新开始，而浏览器每过一段时间都会重新刷新一次，这就会造成界面卡顿；在使用fiber架构之后，任务执行可中断，还可以使用其他API来悄悄的一直运行某个任务，这样就可以让界面更加流畅

这种异步执行任务的架构为以后的react并行操作奠定了基础

#### （5）总结

以上四个部分分别回答了声明式编程、组件化、虚拟DOM以及fiber架构的问题，这些问题都是掌握react的基础



## 9.构建工具（webpack）

### 前言

构建工具是前端工程化的核心，最开始主要解决的是全局变量和依赖关系混乱的问题，核心价值是用模块化的方式写代码，将所有的项目资源全部看做模块，解决模块开发的大问题，使用新技术，解决兼容问题，压缩代码和合并，HMR

### HMR

开发阶段，webpack编译变化的部分，并生成更新补丁，开发服务器使用websocket来告诉浏览器更新了，浏览器请求更新补丁，浏览器中的HMR runtime脚本将旧代码替换成新的。

CSS的样式变动是可以直接使用的，但是部分JS模块，需要进行一定的配置，告诉webpack如何去更新

### loader和plugin

loader webpack只认识JS和JSON文件，对应的loader可以将对应的文件资源转化成webpack可以识别的文件资源 扮演的是翻译官的角色

plugin 扩展webpack的功能，将需要的功能插入的webpack的全部流程中，解决的是宏观的问题，环境的配置、资源的管理、打包的优化、性能的提升，扮演的是项目经历的角色

### 性能优化

webpack有两个问题，打包速度慢以及包大影响性能，但是可以通过优化loader和plugin配置来解决问题

优化打包速度 可以在loader配置中 定义哪些文件需要处理，哪些不需要 进行多进程和多线程的编译 多个CPU核心处理计算资源 

优化打包体积 可以使用对应的plugin插件，tree shaking，静态代码分析，静动态代码分析，缓存机制，按需加载

### 总结

webpack这样的构建工具解决了模块化和新语法使用的问题，HMR热更新提高了开发阶段的体验，loader和plugin帮助webpack处理其他资源文件和扩展新功能，基本上围绕webpack的性能优化是通过loader和plugin进行的

## 10.Git

### 前言

git是世界最主流的代码版本管理工具

### 基本命令

```
git add 
git commit -m ""
git push 
git pull
git status
git log
git checkout -b
git branch --v
git reset --soft/hard
git merge 
git push -u main origin
git stash
git pop
```

### git flow分支管理策略

主分支：main master 可发布生产的稳定版本

开发分支：develop 开发分支

特征分支:feature 从开发分支建立，增加特性、修复bug

hotfix分支：从main主分支建立，修复紧急的、阻断性的bug

## 11.TS

### 前言

TS是JS的超集，为数据类型加上了规则，通过静态类型机制，要求变量声明定义好类型，可以在开发阶段发现潜在的类型错误

### 接口 interface

interface就是描述数据模型，为数据画了个蓝图，定义数据的属性、类型、约定，让代码的意图更加的清晰

### 泛型

同一逻辑可以处理不同类型的代码，提高代码的复用性

### 类 class

和JAVA等传统面向对象语法相似的对象机制，extend继承，private、publick访问控制，让结构更加的清晰

### 应用

在react中，会为state和props定义类型，如果传递的类型不对，IDE会报错，静态代码校验

在vue3中支持很好，vue2的一些库也可以很好的支持

### 总结

TS在JS之上加上了一层类型安全的保护，让代码更加结构化，开发阶段的静态类型检查可以发现很多潜在的类型错误，提高代码的健壮性与维护性，虽然在编译阶段需要babel进行JS的转译，但是和它的工程化好处相比，收获还是很大的

值得思考的是，项目规模在越来越大的时候，JS的自由特性和TS的工程特征的权衡

## 12.Node

让JS在服务器上跑起来

#### 非阻塞异步IO

优点：不傻等，处理大量并发连接的时候，IO密集型任务，读写文件，网络请求，使用相对较少的服务器资源解决问题，吞吐量很高

缺点：单线程处理所有用户请求和用户事件 大量计算任务 复杂的数据运算 图像处理 单线程会被阻塞 没法响应其他的请求 可靠性 单线程因为某个bug就崩溃了

大型应用需要考虑这个问题

#### 事件循环

node的事件循环是核心

setTimeOut setInterval 很细节，在某些场景下，需要非常精确的控制异步操作

nexttick 下一个阶段立刻插队执行

#### 中间件机制

 洋葱模型 一次一次经过中间件函数 每一层都会处理相应的事情 调用next函数，将任务交给下一个中间件 模块化 复用性非常高

#### 总结

非阻塞异步IO和事件驱动模型 IO密集型任务 不适合CPU密集型任务

事件循环高效，但是里面存在一些细节问题

中间件机制 洋葱模型 模块化 复用度高

```
思考：架构设计 进行怎样的错误处理机制呢
```

























