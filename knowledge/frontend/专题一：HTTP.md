# 专题一：HTTP

## 1.网络模型

![image-20250605065944074](C:/Users/13007/AppData/Roaming/Typora/typora-user-images/image-20250605065944074.png)

## 2.TCP与UDP

### TCP与UDP的特点及其区别

![image-20250605070305760](C:/Users/13007/AppData/Roaming/Typora/typora-user-images/image-20250605070305760.png)

#### UDP的特点

- UDP不提供复杂的控制机制，利⽤IP提供⾯向⽆连接的通信服务
-  传输途中出现丢包，UDP也不负责重发
-  当包的到达顺序出现乱序时，UDP没有纠正的功能。
-  并且它是将应⽤程序发来的数据在收到的那⼀刻，⽴即按照原样发送到⽹络上的⼀种机制。即使是
- 出现⽹络拥堵的情况，UDP也⽆法进⾏流量控制等避免⽹络拥塞⾏为

#### TCP的特点

-  TCP充分地实现了数据传输时各种控制功能，可以进⾏丢包时的重发控制，还可以对次序乱掉的分
- 包进⾏顺序控制。⽽这些在UDP中都没有。
-  此外，TCP作为⼀种⾯向有连接的协议，只有在确认通信对端存在时才会发送数据，从⽽可以控制通信流量的浪费。
-  根据TCP的这些机制，在IP这种⽆连接的⽹络上也能够实现⾼可靠性的通信（主要通过检验和、序列号、确认应答、重发控制、连接管理以及窗⼝控制等机制实现）

### 构建在TCP或UDP之上的应用层协议

![image-20250605070351487](C:/Users/13007/AppData/Roaming/Typora/typora-user-images/image-20250605070351487.png)



## 3.TCP的三次握手与四次挥手

### 三次握手

#### 三次握手的过程

- 第⼀次握⼿：客⼾端给服务端发⼀个SYN报⽂，并指明客⼾端的初始化序列号ISN(c)，此时客⼾端处于SYN_SENT状态
- 第⼆次握⼿：服务器收到客⼾端的SYN报⽂之后，会以⾃⼰的SYN报⽂作为应答，为了确认客⼾端的SYN，将客⼾端的ISN+1作为ACK的值，此时服务器处于SYN_RCVD的状态
-  第三次握⼿：客⼾端收到SYN报⽂之后，会发送⼀个ACK报⽂，值为服务器的ISN+1。此时客⼾端处于ESTABLISHED状态。服务器收到ACK报⽂之后，也处于ESTABLISHED状态，此时，双⽅已建⽴起了连接

#### 三次握手的目的

- 第⼀次握⼿：客⼾端发送⽹络包，服务端收到了。这样服务端就能得出结论：客⼾端的发送能⼒、服务端的接收能⼒是正常的。
-  第⼆次握⼿：服务端发包，客⼾端收到了。这样客⼾端就能得出结论：服务端的接收、发送能⼒，客⼾端的接收、发送能⼒是正常的。不过此时服务器并不能确认客⼾端的接收能⼒是否正常
-  第三次握⼿：客⼾端发包，服务端收到了。这样服务端就能得出结论：客⼾端的接收、发送能⼒正常，服务器⾃⼰的发送、接收能⼒也正常通过三次握⼿，就能确定双⽅的接收和发送能⼒是正常的。之后就可以正常通信了



![image-20250605071105960](C:/Users/13007/AppData/Roaming/Typora/typora-user-images/image-20250605071105960.png)



### 四次挥手

#### 四次挥手的过程

- 第⼀次挥⼿：客⼾端发送⼀个FIN报⽂，报⽂中会指定⼀个序列号。此时客⼾端处于FIN_WAIT1状态，停⽌发送数据，等待服务端的确认
- 第⼆次挥⼿：服务端收到FIN之后，会发送ACK报⽂，且把客⼾端的序列号值+1作为ACK报⽂的序列号值，表明已经收到客⼾端的报⽂了，此时服务端处于CLOSE_WAIT状态
-  第三次挥⼿：如果服务端也想断开连接了，和客⼾端的第⼀次挥⼿⼀样，发给FIN报⽂，且指定⼀个序列号。此时服务端处于 LAST_ACK 的状态
- 第四次挥⼿：客⼾端收到FIN之后，⼀样发送⼀个ACK报⽂作为应答，且把服务端的序列号值+1，作为⾃⼰ACK报⽂的序列号值，此时客⼾端处于TIME_WAIT状态。需要过⼀阵⼦以确保服务端收到⾃⼰的ACK报⽂之后才会进⼊CLOSED状态，服务端收到ACK报⽂之后，就处于关闭连接了，处于CLOSED状态

#### 四次挥手的目的

服务端在收到客⼾端断开连接 Fin 报⽂后，并不会⽴即关闭连接，⽽是先发送⼀个 ACK 包先告诉客⼾端收到关闭连接的请求，只有当服务器的所有报⽂发送完毕之后，才发送 FIN 报⽂断开连接，因此需要四次挥⼿

![image-20250605071415010](C:/Users/13007/AppData/Roaming/Typora/typora-user-images/image-20250605071415010.png)



## 4.HTTP

### Post和Get方法

![image-20250605071708767](C:/Users/13007/AppData/Roaming/Typora/typora-user-images/image-20250605071708767.png)

### HTTP常见请求头和响应头

![image-20250605071729158](C:/Users/13007/AppData/Roaming/Typora/typora-user-images/image-20250605071729158.png)

### 304状态码

![image-20250605071835614](C:/Users/13007/AppData/Roaming/Typora/typora-user-images/image-20250605071835614.png)

### 常见HTTP请求方法

![image-20250605071930917](C:/Users/13007/AppData/Roaming/Typora/typora-user-images/image-20250605071930917.png)

OPTIONS请求方法的**主要用途**有两个：

- 获取服务器支持的所有HTTP请求方法；
- 用来检查访问权限。例如：在进行 CORS 跨域资源共享时，对于复杂请求，就是使用 OPTIONS 方法发送嗅探请求，以判断是否有对指定资源的访问权限。



### HTTP1.0与HTTP1.1

HTTP1.0默认支持短连接，即一个连接完成一个资源请求；如果在解析一个html文件时，里面包含了其他文件资源，那么就会进行多次连接，产生了性能上的缺陷

![image-20250605072312230](C:/Users/13007/AppData/Roaming/Typora/typora-user-images/image-20250605072312230.png)

### HTTP2.0

HTTP2与HTTP1相比在性能上有了很大的提升：

- 多路复用
- 二进制分帧
- 头部压缩
- 服务器推送

#### 多路复用

HTTP/2 复⽤ TCP 连接，在⼀个连接⾥，客⼾端和浏览器都可以同时发送多个请求或回应，⽽且不
⽤按照顺序⼀⼀对应，这样就避免了”队头堵塞”

![image-20250605072727056](C:/Users/13007/AppData/Roaming/Typora/typora-user-images/image-20250605072727056.png)

#### 二进制分帧

帧是 HTTP2 通信中最⼩单位信息，HTTP/2 采⽤⼆进制格式传输数据，⽽⾮ HTTP 1.x 的⽂本格式，解析起来更⾼效。将请求和响应数据分割为更⼩的帧，并且它们采⽤⼆进制编码。HTTP2 中，同域名下所有通信都在单个连接上完成，该连接可以承载任意数量的双向数据流。每个数据流都以消息的形式发送，⽽消息⼜由⼀个或多个帧组成。多个帧之间可以乱序发送，根据帧⾸部的流标识可以重新组装，这也是多路复⽤同时发送数据的实现条件

#### 头部压缩

HTTP/2 在客⼾端和服务器端使⽤“⾸部表”来跟踪和存储之前发送的键值对，对于相同的数据，不再通过每次请求和响应发送。⾸部表在 HTTP/2 的连接存续期内始终存在，由客⼾端和服务器共同渐进地更新。例如：下图中的两个请求，请求⼀发送了所有的头部字段，第⼆个请求则只需要发送差异数据，这样可以减少冗余数据，降低开销

![image-20250605072906486](C:/Users/13007/AppData/Roaming/Typora/typora-user-images/image-20250605072906486.png)

#### 服务器推送

HTTP2 引⼊服务器推送，允许服务端推送资源给客⼾端，服务器会顺便把⼀些客⼾端需要的资源⼀起推送到客⼾端，如在响应⼀个⻚⾯请求中，就可以随同⻚
⾯的其它资源，免得客⼾端再次创建连接发送请求到服务器端获取，这种⽅式⾮常合适加载静态资源

![image-20250605072954264](C:/Users/13007/AppData/Roaming/Typora/typora-user-images/image-20250605072954264.png)

### 总结

#### HTTP1.0：

- 浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建⽴⼀个TCP连接

#### HTTP1.1：

- 引⼊了持久连接，即TCP连接默认不关闭，可以被多个请求复⽤
- 在同⼀个TCP连接⾥⾯，客⼾端可以同时发送多个请求
- 虽然允许复⽤TCP连接，但是同⼀个TCP连接⾥⾯，所有的数据通信是按次序进⾏的，服务器只有处理完⼀个请求，才会接着处理下⼀个请求。如果前⾯的处理特别慢，后⾯就会有许多请求排队等着
-  新增了⼀些请求⽅法
-  新增了⼀些请求头和响应头

#### HTTP2.0：

-  采⽤⼆进制格式⽽⾮⽂本格式
-  完全多路复⽤，⽽⾮有序并阻塞的、只需⼀个连接即可实现并⾏
-  使⽤报头压缩，降低开销
-  服务器推送

## 5.HTTPS

在上篇⽂章中，我们了解到 HTTP 在通信过程中，存在以下问题：

- 通信使⽤明⽂（不加密），内容可能被窃听
- 不验证通信⽅的⾝份，因此有可能遭遇伪装

⽽ HTTPS 的出现正是解决这些问题， HTTPS 是建⽴在 SSL 之上，其安全性由 SSL 来保证在采⽤ SSL 后， HTTP 就拥有了 HTTPS 的加密、证书和完整性保护这些功能。SSL(SecureSocketsLayer安全套接字协议),及其继任者传输层安全（TransportLayerSecurity，TLS）是为⽹络通信提供安全及数据完整性的⼀种安全协议

![image-20250605073448843](C:/Users/13007/AppData/Roaming/Typora/typora-user-images/image-20250605073448843.png)

SSL的实现依赖于三种手段：

- 混合加密：对称加密+非对称加密 完成身份认证与密钥协商
- 摘要算法：验证信息的完整性
- 数字签名：身份验证

### 混合加密

服务器和浏览器进行密钥协商，服务器发送数字证书(公钥)给浏览器，协商加密等级，浏览器根据对应加密算法，随机生成对称密钥，用公钥加密对称密钥，发送给服务器，服务器用私钥解密，获取对称密钥，然后用对称密钥对明文进行加密，进行加密通信

![image-20250605073859312](C:/Users/13007/AppData/Roaming/Typora/typora-user-images/image-20250605073859312.png)

上述的⽅法解决了数据加密，在⽹络传输过程中，数据有可能被篡改，并且⿊客可以伪造⾝份发布公钥，如果你获取到假的公钥，那么混合加密也并⽆多⼤⽤处，你的数据扔被⿊客解决。因此，在上述加密的基础上仍需加上完整性、⾝份验证的特性，来实现真正的安全，实现这⼀功能则是摘要算法

### 摘要算法

摘要算法保证了“数字摘要”和原⽂是完全等价的。所以，我们只要在原⽂后附上它的摘要，就能够保证数据的完整性。⽐如，你发了条消息：“转账1000元”，然后再加上⼀个SHA-2的摘要。⽹站收到后也计算⼀下消息的摘要，把这两份“指纹”做个对⽐，如果⼀致，就说明消息是完整可信的，没有被修改

![image-20250605074017964](C:/Users/13007/AppData/Roaming/Typora/typora-user-images/image-20250605074017964.png)

### 数字签名

数字签名能确定消息确实是由发送⽅签名并发出来的，因为别⼈假冒不了发送⽅的签名，原理其实很简单，就是⽤私钥加密，公钥解密。签名和公钥⼀样完全公开，任何⼈都可以获取。但这个签名只有⽤私钥对应的公钥才能解开，拿到摘要后，再⽐对原⽂验证完整性，就可以像签署⽂件⼀样证明消息确实是你发的

![image-20250605074254405](C:/Users/13007/AppData/Roaming/Typora/typora-user-images/image-20250605074254405.png)

和消息本⾝⼀样，因为谁都可以发布公钥，我们还缺少防⽌⿊客伪造公钥的⼿段，也就是说，怎么判断这个公钥就是你的公钥。这时候就需要⼀个第三⽅，就是证书验证机构

### CA验证机构

![image-20250605074627159](C:/Users/13007/AppData/Roaming/Typora/typora-user-images/image-20250605074627159.png)

## 6.CDN

![image-20250605074753418](C:/Users/13007/AppData/Roaming/Typora/typora-user-images/image-20250605074753418.png)

#### CDN原理

![image-20250605074852614](C:/Users/13007/AppData/Roaming/Typora/typora-user-images/image-20250605074852614.png)

#### 负载均衡系统



![image-20250605074940049](C:/Users/13007/AppData/Roaming/Typora/typora-user-images/image-20250605074940049.png)

![image-20250605074823115](C:/Users/13007/AppData/Roaming/Typora/typora-user-images/image-20250605074823115.png)

![image-20250605075016923](C:/Users/13007/AppData/Roaming/Typora/typora-user-images/image-20250605075016923.png)

#### 总结

![image-20250605075041768](C:/Users/13007/AppData/Roaming/Typora/typora-user-images/image-20250605075041768.png)

## 7.DNS

### DNS是什么

![image-20250605075147695](C:/Users/13007/AppData/Roaming/Typora/typora-user-images/image-20250605075147695.png)

### DNS查询

解析域名的过程如下：

- ⾸先搜索浏览器的DNS缓存，缓存中维护⼀张域名与IP地址的对应表

- 若没有命中，则继续搜索操作系统的DNS缓存

- 若仍然没有命中，则操作系统将域名发送⾄本地域名服务器，本地域名服务器采⽤递归查询⾃⼰的DNS缓存，查找成功则返回结果

- 若本地域名服务器的DNS缓存没有命中，则本地域名服务器向上级域名服务器进⾏迭代查询

  - ⾸先本地域名服务器向根域名服务器发起请求，根域名服务器返回顶级域名服务器的地址给本地服务器

  - 本地域名服务器拿到这个顶级域名服务器的地址后，就向其发起请求，获取权限域名服务器的地址
  - 本地域名服务器根据权限域名服务器的地址向其发起请求，最终得到该域名对应的IP地址

- 本地域名服务器将得到的IP地址返回给操作系统，同时⾃⼰将IP地址缓存起来

- 操作系统将IP地址返回给浏览器，同时⾃⼰也将IP地址缓存起

- ⾄此，浏览器就得到了域名对应的IP地址，并将IP地址缓存起

![image-20250605075408184](C:/Users/13007/AppData/Roaming/Typora/typora-user-images/image-20250605075408184.png)

## 8.websocket

![image-20250605075506763](C:/Users/13007/AppData/Roaming/Typora/typora-user-images/image-20250605075506763.png)
