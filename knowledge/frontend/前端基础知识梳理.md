# 前端基础知识梳理

## 一、JS

### 1.数据类型

**数据类型这一专题，包括JS的基本数据类型、内存空间、作用**

JS中的数据类型一共分为两种，分别为基本数据类型与复杂数据类型

其中基本数据类型有7种，它们属于值类型，内存空间是栈

- string 字符型
- number 数值型
- boolean 布尔型
- undefine 未定义
- null 空
- symbol 符号
- bigint 大整数

复杂数据类型有2种，它们属于引用类型，内存空间是堆，引用在栈中存储

- array 数组
- object 对象

```
深入探究：
为什么基本数据类型的内存空间是栈，复杂数据类型是堆？
symbol与bigint的存在意义是什么？
```

### 2.作用域

**作用域这一专题，包括作用域划分、作用域链、变量查找机制、闭包、变量的声明.......**

#### （1）作用域的定义

作用域分为全局作用域与局部作用域，局部作用域又分为块作用域和函数作用域

#### （2）作用域链

作用域链的实质是变量查找机制，即变量的查找会从下向上，一级一级查找，直到找到为止(这也是闭包的底层原理)

#### （3）闭包

**闭包的定义**

闭包是JS非常重要的特性，即子函数可以访问外部函数的变量

**闭包的作用**

闭包的作用有两个保存与保护：

- 保存是将子函数中的变量存储在内存中，即函数执行完毕后，变量依旧存在(这也会造成内存泄漏问题)
- 保护是为了避免其他变量的污染

#### （4）变量的声明

ES6之前，用var声明变量，之后，用let和const声明变量

**var：**声明的变量会绑定到全局变量中，这也是变量提升，即使没有声明也可以访问的原因

为了解决变量提升的问题，ES6提出了let和const。let和const不会将变量绑定到全局变量上面，具备块的概念，即只能在声明变量之后访问变量。以let和const声明语句为分界线，其上为暂时性死区，不能访问变量；其下为变量的块级作用域，可以访问。

**let:**定义变量

**const:**定义常量，需要初始值

**注意：let和const都不能重复声明同一个变量！**

```
值得探究的是闭包的应用场景，函数加工厂
```

### 3.原型

原型这一专题，包括原型链、this、new的过程、class

#### （1）原型链

构造函数的原型对象为自身的prototype，创造的实例的原型proto，会指向构造函数的prototype，然后prototype又会向上指向，object的prototype，最后一直指到null为止

#### （2）new

**new的过程：**

- 创建空对象
- 设置原型为构造函数的prototype原型
- 绑定this，并设置属性和方法
- 返回对象

```
class类的编程方式正在被慢慢淘汰，不是重点，不过理解它们对理解其他编程语言的class编程有很大的帮助
```

### 4.内存管理模式

**引用计数和标记清除法**





### 5.事件循环模型

事件循环模型包括浏览器和node的事件循环模型



### 6.Promise

**Promise专题包括，promise的基本概念、await/async语法糖、异步编程方案以及自己实现promise**



### 7.防抖节流



### 8.apply bind call





### 9.ES6

####  var let const 

var 变量提升 函数作用域(全局作用域) 

let const 主要解决变量提升的问题 块级作用域  在声明前使用会报错，叫做暂时性死区

let 定义变量 重复赋值

const 变量指向的地址不变 声明对象或者数组 对象和数组内部的元素是可以改的  const在声明对象的时候，引用不变，浅层不变  优先用const

#### 异步编程

以前异步编程 回调地狱 代码一层套一层 维护麻烦

promise为了解决回调地狱，本质是一个对象，异步操作最终状态的表示，三个状态 pending rejected fullfiled

链式调用 代码同步

promise.all 多个promise并发执行 promise数组 所有promise都成功才成功，将结果给一个数组   一个失败，失败，将失败原因给你，不会给全部结构

界面加载 用户信息 配置 产品信息 promise.all非常方便

#### 总结：

let const主要解决变量提升的问题，块级作用域叫做暂时性死区，const声明对象，引用不变，属性可变，优先const

promise解决回调地狱问题，链式调用，同步呈现异步操作，界面渲染，用户信息、产品信息、配置信息用promise.all来并行处理，全部成功返回全部成功用数组的形式返回全部成功结构，一个失败直接返回失败原因

### 10.JS

数据怎么去存 闭包是怎么一回事 this又是什么

#### 数据类型

基本数据类型 栈 简单固定

引用数据类型 数据在堆里面 复杂量大 引用在栈里面

#### this

值怎么被调用的，当做对象方法来调用 直接调用函数 非严格模式 指向全局

call apply bind强制改变指向this

es6中的箭头函数，自己没有自己的this，this来定义的时候被定下了，继承的是词法作用域中的this，定义时，外层是什么

闭包 函数执行完了，可以继续访问变量 创建私有变量实现数据封装 通过方法访问 延长变量的生存周期  模块化开发 每个模块都有自己的状态 闭包对于深入掌握JS非常重要

#### 总结

数据类型分为基本和引用，基本数据在栈里面，简单固定、复杂数据在堆里面，复杂量大，引用在栈里面

call apply bind可以强制改变this 箭头函数使用定义外层的this

闭包很重要！内部函数调用外部状态 函数执行完了，状态可以继续使用 创建私有变量外界不能访问只能通过方法获取 延长变量的生存周期 模块化开发 每个模块都有自己的状态 闭包对于深入掌握JS非常的重要！

## 二、React

### 1.react前言知识

前言部分，包括声明式编程、组件化、虚拟DOM以及fiber架构

#### （1）声明式编程

声明式编程就是告诉程序是什么，而不是怎么做，不需要操作dom，直接专注解决问题的逻辑

#### （2）组件化

react中的组件分为类组件和函数组件，早期的类组件可以通过this.state设置自身状态，而函数组件没有状态；react16之后，引入了hook，解决了函数组件没有状态的问题，可以使用useState来设置状态；现在越来越倾向于函数式编程。

说到状态，分为外部状态与自身状态，外部状态通过props来进行组件通信，内部状态通过useState来设置

#### （3）虚拟DOM

直接操作DOM的成本较高，虚拟DOM就是JS对象，操作虚拟DOM的成本较小，再加上diff算法，就可以精准的操作变化的部分，大大提高性能

在进行列表渲染的时候，需要为元素添加key，相当于为每一项列表元素添加身份证，这样再使用diff算法，就可以精确的完成变动，提高性能

#### （4）fiber架构

react16之前，在执行任务的时候，需要一鼓作气的完成，不能中断，中断就要重新开始，而浏览器每过一段时间都会重新刷新一次，这就会造成界面卡顿；在使用fiber架构之后，任务执行可中断，还可以使用其他API来悄悄的一直运行某个任务，这样就可以让界面更加流畅

这种异步执行任务的架构为以后的react并行操作奠定了基础

#### （5）总结

以上四个部分分别回答了声明式编程、组件化、虚拟DOM以及fiber架构的问题，这些问题都是掌握react的基础

## 三、Vue

### 1.vue前言知识

#### （1）组合式API

vue3和vue2在关于代码组织的上面给出了不同的答案，vue2使用的是配置式API，data、method、watch都要分开组织，不同功能的数据、方法、监听都混在了一起；而vue3使用的是组合式API，将相同功能的数据、方法等逻辑放在一起，以提高代码的内聚性；

最典型的例子就是mixin，mixin的数据不清晰，需要使用hook来提高，复用逻辑清晰可见

#### （2）响应式系统

vue2的响应式系统使用的是defineProperty，具有数据增删改存在监视缺漏、数组类型数据监视不了的问题；而vue3使用的是ES6的proxy，相当于给整个数据对象都加上了一层代理，统一监视所有数据对象的变化，不需要额外的API，性能也更好，但是存在不兼容老IE的问题，不过babel会帮助我们解决的！

vue3的响应式系统使用的JS的原生功能，解决了数据对象的监视问题，提高了性能

#### （3）性能优化

在diff算法上，编译阶段会将变化的状态进行标记，然后只比较标记的部分，减少不必要的比较，提高diff的性能

编译器会将静态内容提取出来，采用静动态代码分割策略，一次复用（静态提升）

tree shaking会将没用到的代码都摇掉，减小包的体积

组件传送门可以全局处理UI元素

#### （4）总结

vue3与vue2的不同在于，代码组织模式、响应式系统和性能优化上，其中代码组织模式使用了功能逻辑更加清晰可见的组合式API，响应式系统使用了proxy来统一加上一层代理进行数据监视，性能优化上包括编译时的diff标记、静动态代码分割、tree shakiing，使用上引用了功能繁多的hook























## 四、构建工具











## 五、Git

### 1.git基本命令

git是目前世界最主流的代码管理模式，它的定义是分布式代码管理模式

git的基本命令有：

```
git status 查看状态 提交的情况
git log 查看commit 历史
git clone 克隆代码
git add 指定添加修改文件进入缓存区
git commit 提交缓存区的代码 注意要遵循提交规范
git push 推送远程代码仓库
git pull 拉取代码
git push/pull -u origin:xxx 设置上流分支
git branch --set-upstream-to=origin/远程分支名 设置pull和push的上流分支
git checkout xxx 切换
git branch 分支操作
git stash 暂存
git pop 使用暂存
git reset xxx --hard/soft 回滚版本
```

以上属于git的基本命令，如果再进行复杂的操作，一般会使用企业级的git可视化操作工具

### 2.git flow项目管理策略

git flow项目管理策略将git branch分为以下几个类型：

- master/main 主分支 稳定的、可发布的版本
- hotfix 基于主分支，用于解决生产环境下的严重bug
- develop 开发分支
- feature 功能分支 开发功能、修复bug(基于develop)
- release 版本分支 用于发布版本(基于develop分支)



### 六、CSS

### 1.css前言知识

#### 盒子模型

content-box  正常盒模型 分别计算width height margin padding

border-box width和height将margin和padding包含进去了

像素级对齐

#### BFC 块级格式化上下文

核心在于隔离，BFC可以解决不少问题，将浮动元素包裹，解决父元素塌陷的问题，外边距叠加问题

#### 元素居中

flex和grid实现元素居中

display flex justify-conent:center  

grid 

flex主要是一维布局系统 单行和单列元素的对齐 flex box非常顺畅

grid控制行和列 整个界面的宏观布局 圣杯布局 

小范围、组件内部使用flex好一些，grid宏观布局

#### 计算单位

px绝对单位 vm相对单位，根元素尺寸，

无障碍访问

#### 总结

盒子模型 content-box 单独计算各个部分 border-box 宽高决定一切

BFC 隔离元素 解决元素坍塌问题 边距叠加问题

元素居中 flex grid

计算单位 响应式

我的css基础真的很差劲！！！！

## 七、node

让JS在服务器上跑起来

### 1.前言知识

#### 非阻塞异步IO

优点：不傻等，处理大量并发连接的时候，IO密集型任务，读写文件，网络请求，使用相对较少的服务器资源解决问题，吞吐量很高

缺点：单线程处理所有用户请求和用户事件 大量计算任务 复杂的数据运算 图像处理 单线程会被阻塞 没法响应其他的请求 可靠性 单线程因为某个bug就崩溃了

大型应用需要考虑这个问题

#### 事件循环

node的事件循环是核心

setTimeOut setInterval 很细节，在某些场景下，需要非常精确的控制异步操作

nexttick 下一个阶段立刻插队执行

#### 中间件机制

 洋葱模型 一次一次经过中间件函数 每一层都会处理相应的事情 调用next函数，将任务交给下一个中间件 模块化 复用性非常高

#### 总结

非阻塞异步IO和事件驱动模型 IO密集型任务 不适合CPU密集型任务

事件循环高效，但是里面存在一些细节问题

中间件机制 洋葱模型 模块化 复用度高

```
思考：架构设计 进行怎样的错误处理机制呢
```





































